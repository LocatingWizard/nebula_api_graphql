package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"

	"github.com/LocatingWizard/nebula_api_graphql/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Requirement is the resolver for the requirement field.
func (r *possibleOutcomesResolver) Requirement(ctx context.Context, obj *model.PossibleOutcomes) (model.Requirement, error) {
	bytes, _ := bson.Marshal(obj.Requirement)
	switch obj.Requirement.Index(1).Key() {
	case "class_reference":
		var t model.CourseRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "section_reference":
		var t model.SectionRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "exam_reference":
		var t model.ExamRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "major":
		var t model.MajorRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "minor":
		var t model.MinorRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "minimum":
		var t model.GPARequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "granter":
		var t model.ConsentRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "options":
		var t model.CollectionRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "required":
		var t model.HoursRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "description":
		var t model.OtherRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "choices":
		var t model.ChoiceRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "max_hours":
		var t model.LimitRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "core_flag":
		var t model.CoreRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	default:
		panic("Unable to resolve Requirement")
	}
}

// PossibleOutcomes is the resolver for the possible_outcomes field.
func (r *possibleOutcomesResolver) PossibleOutcomes(ctx context.Context, obj *model.PossibleOutcomes) ([][]model.Outcome, error) {
	var out [][]model.Outcome
	for _, v := range obj.PossibleOutcomes {
		fmt.Println(v)
		if len(v) == 0 {
			continue
		}
		var ids []primitive.ObjectID
		vals, err := v.Values()
		if err != nil {
			fmt.Println(err)
			return nil, err
		}
		for _, w := range vals {
			ids = append(ids, w.ObjectID())
		}
		var courses []model.Outcome
		for _, w := range ids {
			course, err := r.Query().CourseByID(ctx, w.Hex())
			if err != nil {
				fmt.Println(err)
				return nil, err
			}
			courses = append(courses, course)
		}
		out = append(out, courses)
		fmt.Println(ids)
	}
	return out, nil

	// var out [][]model.Outcome
	// fmt.Println(obj.PossibleOutcomes)
	// for _, v := range obj.PossibleOutcomes {
	// 	fmt.Println(*v)
	// 	var ids []primitive.ObjectID
	// 	fmt.Println("\n\n\nLigma1\n\n\n")
	// 	_, bytes, err := bson.MarshalValue(v)
	// 	if err != nil {
	// 		fmt.Println(err)
	// 		return nil, err
	// 	}
	// 	fmt.Println("here?")
	// 	bson.Unmarshal(bytes, &ids)
	// 	fmt.Println("here2?")
	// 	fmt.Println(ids)
	// 	var temp []model.Outcome
	// 	for _, w := range ids {
	// 		fmt.Println("lol")
	// 		course, err := r.Query().CourseByID(ctx, w.String())
	// 		if err != nil {
	// 			fmt.Println(err)
	// 			return nil, err
	// 		}
	// 		temp = append(temp, course)
	// 	}

	// 	out = append(out, temp)
	// }
	// return out, nil
}

// PossibleOutcomes returns PossibleOutcomesResolver implementation.
func (r *Resolver) PossibleOutcomes() PossibleOutcomesResolver { return &possibleOutcomesResolver{r} }

type possibleOutcomesResolver struct{ *Resolver }
