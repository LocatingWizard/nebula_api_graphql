package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"

	"github.com/LocatingWizard/nebula_api_graphql/graph/model"
	"go.mongodb.org/mongo-driver/bson"
)

// Requirement is the resolver for the requirement field.
func (r *possibleOutcomesResolver) Requirement(ctx context.Context, obj *model.PossibleOutcomes) (model.Requirement, error) {
	bytes, _ := bson.Marshal(obj.Requirement)
	switch obj.Requirement.Index(1).Key() {
	case "class_reference":
		var t model.CourseRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "section_reference":
		var t model.SectionRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "exam_reference":
		var t model.ExamRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "major":
		var t model.MajorRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "minor":
		var t model.MinorRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "minimum":
		var t model.GPARequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "granter":
		var t model.ConsentRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "options":
		var t model.CollectionRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "required":
		var t model.HoursRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "description":
		var t model.OtherRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "choices":
		var t model.ChoiceRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "max_hours":
		var t model.LimitRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "core_flag":
		var t model.CoreRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	default:
		panic("Unable to resolve Requirement")
	}
}

// PossibleOutcomes is the resolver for the possible_outcomes field.
func (r *possibleOutcomesResolver) PossibleOutcomes(ctx context.Context, obj *model.PossibleOutcomes) ([][]model.Outcome, error) {
	panic(fmt.Errorf("not implemented: PossibleOutcomes - possible_outcomes"))
}

// PossibleOutcomes returns PossibleOutcomesResolver implementation.
func (r *Resolver) PossibleOutcomes() PossibleOutcomesResolver { return &possibleOutcomesResolver{r} }

type possibleOutcomesResolver struct{ *Resolver }
