package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"

	"github.com/LocatingWizard/nebula_api_graphql/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/bsontype"
)

// Requirement is the resolver for the requirement field.
func (r *possibleOutcomesResolver) Requirement(ctx context.Context, obj *model.PossibleOutcomes) (model.Requirement, error) {
	bytes, _ := bson.Marshal(obj.Requirement)
	switch obj.Requirement.Index(1).Key() {
	case "class_reference":
		var t model.CourseRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "section_reference":
		var t model.SectionRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "exam_reference":
		var t model.ExamRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "major":
		var t model.MajorRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "minor":
		var t model.MinorRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "minimum":
		var t model.GPARequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "granter":
		var t model.ConsentRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "options":
		var t model.CollectionRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "required":
		var t model.HoursRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "description":
		var t model.OtherRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "choices":
		var t model.ChoiceRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "max_hours":
		var t model.LimitRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	case "core_flag":
		var t model.CoreRequirement
		bson.Unmarshal(bytes, &t)
		return t, nil
	default:
		panic("Unable to resolve Requirement")
	}
}

// PossibleOutcomes is the resolver for the possible_outcomes field.
func (r *possibleOutcomesResolver) PossibleOutcomes(ctx context.Context, obj *model.PossibleOutcomes) ([][]model.Outcome, error) {
	var out [][]model.Outcome
	for _, v := range obj.PossibleOutcomes {
		var temp []model.Outcome
		vals, err := v.Values()
		if err != nil {
			fmt.Println(err)
			return nil, err
		}
		for _, w := range vals {
			if w.Type == bsontype.ObjectID {
				id := w.ObjectID().Hex()
				course, err := r.Query().CourseByID(ctx, id)
				if err != nil {
					fmt.Println(err)
					return nil, err
				}
				temp = append(temp, course)
			} else if w.Type == bsontype.EmbeddedDocument {
				var credit model.Credit
				w.Unmarshal(&credit)
				temp = append(temp, credit)
			}
		}
		out = append(out, temp)
	}
	return out, nil
}

// PossibleOutcomes returns PossibleOutcomesResolver implementation.
func (r *Resolver) PossibleOutcomes() PossibleOutcomesResolver { return &possibleOutcomesResolver{r} }

type possibleOutcomesResolver struct{ *Resolver }
