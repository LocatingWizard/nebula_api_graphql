package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.27

import (
	"context"
	"fmt"

	"github.com/LocatingWizard/nebula_api_graphql/graph/model"
	"go.mongodb.org/mongo-driver/bson"
)

// Options is the resolver for the options field.
func (r *collectionRequirementResolver) Options(ctx context.Context, obj *model.CollectionRequirement) ([]model.Requirement, error) {
	var out []model.Requirement
	for _, v := range obj.Options {

		bytes, err := bson.Marshal(v)
		if err != nil {
			return nil, err
		}

		optionType := v.Lookup("type").StringValue()

		switch optionType {
		case "course":
			var t model.CourseRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "section":
			var t model.SectionRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "exam":
			var t model.ExamRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "major":
			var t model.MajorRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "minor":
			var t model.MinorRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "gpa":
			var t model.GPARequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "consent":
			var t model.ConsentRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "collection":
			var t model.CollectionRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "hours":
			var t model.HoursRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "other":
			var t model.OtherRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "choice":
			var t model.ChoiceRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "limit":
			var t model.LimitRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		case "core":
			var t model.CoreRequirement
			bson.Unmarshal(bytes, &t)
			out = append(out, t)
		default:
			return nil, fmt.Errorf("unkown option type: %v", err)
		}
	}
	return out, nil
}

// ClassReference is the resolver for the class_reference field.
func (r *courseRequirementResolver) ClassReference(ctx context.Context, obj *model.CourseRequirement) (*model.Course, error) {
	id := obj.ClassReference
	course, err := r.Query().CourseByID(ctx, id.Hex())
	if err != nil {
		return nil, err
	}
	return course, nil
}

// ExamReference is the resolver for the exam_reference field.
func (r *examRequirementResolver) ExamReference(ctx context.Context, obj *model.ExamRequirement) (model.Exam, error) {
	id := obj.ExamReference
	exam, err := r.Query().ExamByID(ctx, id.Hex())
	if err != nil {
		return nil, err
	}
	return exam, nil
}

// CollectionRequirement returns CollectionRequirementResolver implementation.
func (r *Resolver) CollectionRequirement() CollectionRequirementResolver {
	return &collectionRequirementResolver{r}
}

// CourseRequirement returns CourseRequirementResolver implementation.
func (r *Resolver) CourseRequirement() CourseRequirementResolver {
	return &courseRequirementResolver{r}
}

// ExamRequirement returns ExamRequirementResolver implementation.
func (r *Resolver) ExamRequirement() ExamRequirementResolver { return &examRequirementResolver{r} }

type collectionRequirementResolver struct{ *Resolver }
type courseRequirementResolver struct{ *Resolver }
type examRequirementResolver struct{ *Resolver }
